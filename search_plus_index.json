{"./":{"url":"./","title":"前言","keywords":"","body":"Go 学习笔记 kyoyp Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-05-19 12:03:19 "},"go/constant/":{"url":"go/constant/","title":"常量","keywords":"","body":"常量的定义 定义常量使用const关键字，用于存储一些不会改变的数据。常量支持的数据类型：布尔型（bool）、数字型（整数[int]、浮点数[float]、复数[complex]）和字符串型（string）。 定义格式：const identifier [type] = value，例如： const name string = \"Lsc\" 定义常量的类型（type）可以省略，会根据上下文来获得相关的类型，和字面常量一样,称为无类型（untyped）常量。 字面常量（literal），是指程序中硬编码的常量，如：-12。它们的值即为它们本身，是无法被改变的。 常量表达式 常量定义也可以是常量表达式: const a = 2.6 * 3 + 6 const c = \"a\" + \"b\" 但是表达式中不能含有变量，例如： // 这样不正确 var b = 2.6 const a = 2.6 * 3 + b 也不能是函数，例如 var a = math.Sqrt(4) // 允许 const b = math.Sqrt(4) // 不允许 预定义常量 Go预定义的一些常量：true、false、iota，true和false是布尔常量，而iota比较特殊，可以认为是一个能被编译器修改的常量。一个 const 声明内的每一行常量声明，将会自动套用前面的 iota 格式，并自动增加1，即使被中断，恢复后接着当前常量位置（索引）的继续递增，看下面的例子： package main import ( \"fmt\" ) func main() { const ( a = iota // 0 b // 1 c // 2 d = 8 // 3 ，这里被中断，之后的常量如果没有初始化，也是等于改值，即：e = 8, f = 8 e // 4 f // 5 g = iota // 6 ，这里又恢复为iota，即 g = 6, h = 7 h // 7 ) fmt.Println(a,b,c,d,e,f,g,h) } // 输出 0 1 2 8 8 8 6 7 实例：将枚举值转化为字符串 下面是根据枚举值显示相应的字符串，参考文章：http://c.biancheng.net/view/24.html package main import ( \"fmt\" ) // 声明语言的类型 type LanguageType int // 定义类型常量 const ( None LanguageType = iota Go PHP Python ) // 定义一个字符串函数 func (l LanguageType) String() string { switch l { case None: return \"None\" case Go: return \"Go\" case PHP: return \"PHP\" case Python: return \"Python\" } return \"N/A\" } func main() { // 输出Go的值并以整型格式显示 fmt.Printf(\"%s %d\\n\", None, None) fmt.Printf(\"%s %d\\n\", Go, Go) fmt.Printf(\"%s %d\\n\", Python, Python) } // 输出 None 0 Go 1 Python 3 使用 String() 方法的 LanguageType 在使用上和普通的常量没有区别。当这个类型需要显示为字符串时，Go 语言会自动寻找 String() 方法并进行调用。 总结 常量可以定义后不使用，而变量定义后必须使用 常量的值必须是能够在编译时就能够确定的，不能是变量或者函数 在分配过程中不允许有混合类型 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-05-23 14:30:54 "},"go/data/":{"url":"go/data/","title":"数据类型","keywords":"","body":"不论任何一种语言，都有数据类型的概念，我们常见的基本数据类型有：整型(int)、浮点型(float)、布尔型(bool)、字符串(string)。Go 除了几种基本类型外，还有指针(pointer)、数组(array)、结构体(struct)、通道(channel)、函数(func)、切片(slice)、接口(interface)、集合(map)。 下面是Go的几种基本数据类型的介绍 布尔型（bool） bool 类型表示一个布尔值，值为只有两种 true 或者 false。 package main import ( \"fmt\" \"unsafe\" ) func main() { var a bool = true var b bool = false fmt.Printf(\"a: type is %T, size is %d\\n\", a, unsafe.Sizeof(a)) fmt.Printf(\"b: type is %T, size is %d\", b, unsafe.Sizeof(b)) } // 输出 a: type is bool, size is 1 b: type is bool, size is 1 整型（int） 整型分为 有符号整型（int）和 无符号整型（uint） 类型 大小 范围 有符号整型 int8 8位 -128～127 int16 16位 -32768～32767 int32 32位 -2147483648～2147483647 int64 64位 -9223372036854775808～9223372036854775807 无符号整型 uint8 8位 0~255 uint16 16位 0～65535 uint32 32位 0～4294967295 uint64 64位 0～18446744073709551615 uint8 就是我们熟知的 byte 型，int16 对应C语言中的 short 型，int64 对应C语言中的 long 型。 int：根据不同的底层平台，表示 32 或 64 位整型。 uint：根据不同的底层平台，表示 32 或 64 位无符号整型。 byte 是 uint8 的别名。 rune 是 int32 的别名。 package main import ( \"fmt\" \"unsafe\" ) func main() { var a int = -12 var b int8 = -88 var c uint = 12 var d uint8 = 88 fmt.Printf(\"a: type is %T, size is %d\\n\", a, unsafe.Sizeof(a)) fmt.Printf(\"b: type is %T, size is %d\\n\", b, unsafe.Sizeof(b)) fmt.Printf(\"c: type is %T, size is %d\\n\", c, unsafe.Sizeof(c)) fmt.Printf(\"d: type is %T, size is %d\\n\", d, unsafe.Sizeof(d)) } // 输出 a: type is int, size is 8 b: type is int8, size is 1 c: type is uint, size is 8 d: type is uint8, size is 1 浮点型（float） 浮点型分为 32位浮点型（float32）和 64位浮点型（float64），一般来说，CPU处理单精度浮点数的速度比处理双精度浮点数快。 类型 有效位数 常量 范围 字节数 float32 8位 最大值:math.MaxFloat32最小值:math.MinFloat32 -3.40E+38 ~ +3.40E+38 4个字节 float64 16位 最大值:math.MaxFloat64最小值:math.MinFloat64 -1.79E+308 ~ +1.79E+308 8个字节 package main import ( \"fmt\" \"unsafe\" ) func main() { var a float32 = 18.88 var b float64 = 18.88 var c = 18.88 fmt.Printf(\"a = %f: type is %T, size is %d\\n\", a, a, unsafe.Sizeof(a)) fmt.Printf(\"b = %f: type is %T, size is %d\\n\", b, b, unsafe.Sizeof(b)) fmt.Printf(\"c = %f: type is %T, size is %d\\n\", c, c, unsafe.Sizeof(c)) } // 输出 a = 18.879999: type is float32, size is 4 b = 18.880000: type is float64, size is 8 c = 18.880000: type is float64, size is 8 可以看出同一个小数，不同的精度输出值不同，当然，如果小数位数达到有效位数，会现实相同的值 复数型（complex） 复数型分为 64位（complex64）和 128位（complex128） 使用内建函数 complex 创建一个复数，complex 函数定义如下： func complex(r, i FloatType) ComplexType 第一个参数是实部，第二个参数是虚部，返回复数类型 实部和虚部的值应该是同种类型，float32 或者 float64 如果是float32，返回 complex64 类型的复数 如果是float64，返回 complex128 类型的复数 使用简短语法 var c complex64 = 6 + 8i 看一下这个例子，更容易理解一些 package main import ( \"fmt\" \"unsafe\" ) func main() { var a complex64 = 6 + 8i b := 6 + 8i d := complex(float32(6), 8) c := complex(6, 8) fmt.Printf(\"a = %G: type is %T, size is %d\\n\", a, a, unsafe.Sizeof(a)) fmt.Printf(\"b = %G: type is %T, size is %d\\n\", b, b, unsafe.Sizeof(b)) fmt.Printf(\"c = %G: type is %T, size is %d\\n\", c, c, unsafe.Sizeof(c)) fmt.Printf(\"d = %G: type is %T, size is %d\\n\", d, d, unsafe.Sizeof(d)) } // 输出 a = (6+8i): type is complex64, size is 8 b = (6+8i): type is complex128, size is 16 c = (6+8i): type is complex128, size is 16 d = (6+8i): type is complex64, size is 8 字符串（string） 字符串是字节的集合，可以认为是一个字符串是由很多的字符组成。字符串定义很简单，直接用双引号\"包含内容，被称为字符串字面量（string literal）。 en := \"hello go\" ch := \"你好，go\" Go字符串的内部实现是使用 UTF-8 编码，通过 rune 类型可以方便的访问每一个 UTF-8 字符，也支持按传统的 ASCII 码方式进行逐字符访问。 package main import ( \"fmt\" ) func main() { ch := \"你好，go\" for _, ch := range ch { fmt.Printf(\"%d - %c\\n\", rune(ch), ch) } } # 输出 20320 - 你 22909 - 好 65292 - ， 103 - g 111 - o 定义多行字符串 双引号定义的字符串不能跨行，要想跨行，可以使用反引号(`)定义，但是，所有的转义字符均无效，文本将会原样输出。 package main import ( \"fmt\" ) func main() { str := ` 你好 go ` fmt.Println(str) } 输出内容带有h1标签： 你好 go Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-05-22 15:25:28 "},"go/data/format.html":{"url":"go/data/format.html","title":"格式化输出","keywords":"","body":" 格式 含义 %% 一个%字面量 %b 一个二进制整数值(基数为2)，或者是一个(高级的)用科学计数法表示的指数为2的浮点数 %c 字符型。可以把输入的数字按照ASCII码相应转换为对应的字符 %d 一个十进制数值(基数为10) %e 以科学记数法e表示的浮点数或者复数值 %E 以科学记数法E表示的浮点数或者复数值 %f 以标准记数法表示的浮点数或者复数值 %g 以%e或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出 %G 以%E或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出 %o 一个以八进制表示的数字(基数为8) %p 以十六进制(基数为16)表示的一个值的地址，前缀为0x,字母使用小写的a-f表示 %q 使用Go语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字 %s 字符串。输出字符串中的字符直至字符串中的空字符（字符串以'\\0‘结尾，这个'\\0'即空字符） %t 以true或者false输出的布尔值 %T 使用Go语法输出的值的类型 %U 一个用Unicode表示法表示的整型码点，默认值为4个数字字符 %v 使用默认格式输出的内置或者自定义类型的值，或者是使用其类型的String()方式输出的自定义值，如果该方法存在的话 %x 以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示 %X 以十六进制表示的整型值(基数为十六)，数字A-F使用小写表示 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-05-22 14:23:00 "},"go/data/conversion.html":{"url":"go/data/conversion.html","title":"数据类型转换","keywords":"","body":"超强类型 Go 是强类型语言，在类型约束方面甚至比 C 更严格，比如：在 C 中整型和浮点型可以运算，而在 Go 中是不允许的： C 语言代码： #include int main() { int a = 6; double b = 6.8; double sum; sum = a + b; printf(\"%d + %f = %f\", a, b, sum); } // 输出 6 + 6.800000 = 12.800000 Go 语言代码： package main import \"fmt\" func main() { var a int = 6 var b float64 = 6.8 var sum float64 sum = a + b // sum = float64(a) + b 显示转换后，这样是正确的 fmt.Println(sum) } // 输出 # command-line-arguments test/test21.go:10:10: invalid operation: a + b (mismatched types int and float64) 常见类型转换 除了常见的同类（数字、浮点等等）型之间的转换，如：int、int32、float32等等之外，还有就是跨类型的转换：字符串转为整型、整型转为字符串等等。 字符串数字常量转为整型 package main import ( \"fmt\" \"strconv\" \"unsafe\" ) func main() { a := \"68\" b,_ := strconv.Atoi(a) // Atoi是ParseInt的简写 c,_ := strconv.ParseInt(a, 10, 0) fmt.Printf(\"a = %s : type is %T, size of %d\\n\", a, a, unsafe.Sizeof(a)) fmt.Printf(\"b = %d : type is %T, size of %d\\n\", b, b, unsafe.Sizeof(b)) fmt.Printf(\"c = %d : type is %T, size of %d\\n\", c, c, unsafe.Sizeof(c)) } // 输出 a : type is string, size of 16 b : type is int, size of 8 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-05-24 13:28:04 "},"go/string/":{"url":"go/string/","title":"字符串","keywords":"","body":"Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-05-22 08:37:21 "}}