{"./":{"url":"./","title":"资源列表","keywords":"","body":"下面是我在学习过程中参考前辈们的资料，谢谢大家分享的经验，如有侵权麻烦通知(liusweets@163.com)，会马上处理。 GO 文档 官方文档 https://golang.google.cn Go语言中文网 https://studygolang.com Go语言四十二章经 https://www.jianshu.com/nb/29056963 数据库 GORM中文文档 http://gorm.book.jasperxu.com Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-06-26 09:51:33 "},"go/base/":{"url":"go/base/","title":"基础知识","keywords":"","body":"Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-06-26 09:31:18 "},"go/base/constant/":{"url":"go/base/constant/","title":"常量","keywords":"","body":"常量的定义 定义常量使用const关键字，用于存储一些不会改变的数据。常量支持的数据类型：布尔型（bool）、数字型（整数[int]、浮点数[float]、复数[complex]）和字符串型（string）。 定义格式：const identifier [type] = value，例如： const name string = \"Lsc\" 定义常量的类型（type）可以省略，会根据上下文来获得相关的类型，和字面常量一样,称为无类型（untyped）常量。 字面常量（literal），是指程序中硬编码的常量，如：-12。它们的值即为它们本身，是无法被改变的。 常量表达式 常量定义也可以是常量表达式: const a = 2.6 * 3 + 6 const c = \"a\" + \"b\" 但是表达式中不能含有变量，例如： // 这样不正确 var b = 2.6 const a = 2.6 * 3 + b 也不能是函数，例如 var a = math.Sqrt(4) // 允许 const b = math.Sqrt(4) // 不允许 预定义常量 Go预定义的一些常量：true、false、iota，true和false是布尔常量，而iota比较特殊，可以认为是一个能被编译器修改的常量。一个 const 声明内的每一行常量声明，将会自动套用前面的 iota 格式，并自动增加1，即使被中断，恢复后接着当前常量位置（索引）的继续递增，看下面的例子： package main import ( \"fmt\" ) func main() { const ( a = iota // 0 b // 1 c // 2 d = 8 // 3 ，这里被中断，之后的常量如果没有初始化，也是等于改值，即：e = 8, f = 8 e // 4 f // 5 g = iota // 6 ，这里又恢复为iota，即 g = 6, h = 7 h // 7 ) fmt.Println(a,b,c,d,e,f,g,h) } // 输出 0 1 2 8 8 8 6 7 实例：将枚举值转化为字符串 下面是根据枚举值显示相应的字符串，参考文章：http://c.biancheng.net/view/24.html package main import ( \"fmt\" ) // 声明语言的类型 type LanguageType int // 定义类型常量 const ( None LanguageType = iota Go PHP Python ) // 定义一个字符串函数 func (l LanguageType) String() string { switch l { case None: return \"None\" case Go: return \"Go\" case PHP: return \"PHP\" case Python: return \"Python\" } return \"N/A\" } func main() { // 输出Go的值并以整型格式显示 fmt.Printf(\"%s %d\\n\", None, None) fmt.Printf(\"%s %d\\n\", Go, Go) fmt.Printf(\"%s %d\\n\", Python, Python) } // 输出 None 0 Go 1 Python 3 使用 String() 方法的 LanguageType 在使用上和普通的常量没有区别。当这个类型需要显示为字符串时，Go 语言会自动寻找 String() 方法并进行调用。 总结 常量可以定义后不使用，而变量定义后必须使用 常量的值必须是能够在编译时就能够确定的，不能是变量或者函数 在分配过程中不允许有混合类型 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-05-23 14:30:54 "},"go/base/data/":{"url":"go/base/data/","title":"数据类型","keywords":"","body":"不论任何一种语言，都有数据类型的概念，我们常见的基本数据类型有：整型(int)、浮点型(float)、布尔型(bool)、字符串(string)。Go 除了几种基本类型外，还有指针(pointer)、数组(array)、结构体(struct)、通道(channel)、函数(func)、切片(slice)、接口(interface)、集合(map)。 下面是Go的几种基本数据类型的介绍 布尔型（bool） bool 类型表示一个布尔值，值为只有两种 true 或者 false。 package main import ( \"fmt\" \"unsafe\" ) func main() { var a bool = true var b bool = false fmt.Printf(\"a: type is %T, size is %d\\n\", a, unsafe.Sizeof(a)) fmt.Printf(\"b: type is %T, size is %d\", b, unsafe.Sizeof(b)) } // 输出 a: type is bool, size is 1 b: type is bool, size is 1 整型（int） 整型分为 有符号整型（int）和 无符号整型（uint） 类型 大小 范围 有符号整型 int8 8位 -128～127 int16 16位 -32768～32767 int32 32位 -2147483648～2147483647 int64 64位 -9223372036854775808～9223372036854775807 无符号整型 uint8 8位 0~255 uint16 16位 0～65535 uint32 32位 0～4294967295 uint64 64位 0～18446744073709551615 uint8 就是我们熟知的 byte 型，int16 对应C语言中的 short 型，int64 对应C语言中的 long 型。 int：根据不同的底层平台，表示 32 或 64 位整型。 uint：根据不同的底层平台，表示 32 或 64 位无符号整型。 byte 是 uint8 的别名。 rune 是 int32 的别名。 package main import ( \"fmt\" \"unsafe\" ) func main() { var a int = -12 var b int8 = -88 var c uint = 12 var d uint8 = 88 fmt.Printf(\"a: type is %T, size is %d\\n\", a, unsafe.Sizeof(a)) fmt.Printf(\"b: type is %T, size is %d\\n\", b, unsafe.Sizeof(b)) fmt.Printf(\"c: type is %T, size is %d\\n\", c, unsafe.Sizeof(c)) fmt.Printf(\"d: type is %T, size is %d\\n\", d, unsafe.Sizeof(d)) } // 输出 a: type is int, size is 8 b: type is int8, size is 1 c: type is uint, size is 8 d: type is uint8, size is 1 浮点型（float） 浮点型分为 32位浮点型（float32）和 64位浮点型（float64），一般来说，CPU处理单精度浮点数的速度比处理双精度浮点数快。 类型 有效位数 常量 范围 字节数 float32 8位 最大值:math.MaxFloat32最小值:math.MinFloat32 -3.40E+38 ~ +3.40E+38 4个字节 float64 16位 最大值:math.MaxFloat64最小值:math.MinFloat64 -1.79E+308 ~ +1.79E+308 8个字节 package main import ( \"fmt\" \"unsafe\" ) func main() { var a float32 = 18.88 var b float64 = 18.88 var c = 18.88 fmt.Printf(\"a = %f: type is %T, size is %d\\n\", a, a, unsafe.Sizeof(a)) fmt.Printf(\"b = %f: type is %T, size is %d\\n\", b, b, unsafe.Sizeof(b)) fmt.Printf(\"c = %f: type is %T, size is %d\\n\", c, c, unsafe.Sizeof(c)) } // 输出 a = 18.879999: type is float32, size is 4 b = 18.880000: type is float64, size is 8 c = 18.880000: type is float64, size is 8 可以看出同一个小数，不同的精度输出值不同，当然，如果小数位数达到有效位数，会现实相同的值 复数型（complex） 复数型分为 64位（complex64）和 128位（complex128） 使用内建函数 complex 创建一个复数，complex 函数定义如下： func complex(r, i FloatType) ComplexType 第一个参数是实部，第二个参数是虚部，返回复数类型 实部和虚部的值应该是同种类型，float32 或者 float64 如果是float32，返回 complex64 类型的复数 如果是float64，返回 complex128 类型的复数 使用简短语法 var c complex64 = 6 + 8i 看一下这个例子，更容易理解一些 package main import ( \"fmt\" \"unsafe\" ) func main() { var a complex64 = 6 + 8i b := 6 + 8i d := complex(float32(6), 8) c := complex(6, 8) fmt.Printf(\"a = %G: type is %T, size is %d\\n\", a, a, unsafe.Sizeof(a)) fmt.Printf(\"b = %G: type is %T, size is %d\\n\", b, b, unsafe.Sizeof(b)) fmt.Printf(\"c = %G: type is %T, size is %d\\n\", c, c, unsafe.Sizeof(c)) fmt.Printf(\"d = %G: type is %T, size is %d\\n\", d, d, unsafe.Sizeof(d)) } // 输出 a = (6+8i): type is complex64, size is 8 b = (6+8i): type is complex128, size is 16 c = (6+8i): type is complex128, size is 16 d = (6+8i): type is complex64, size is 8 字符串（string） 字符串是字节的集合，可以认为是一个字符串是由很多的字符组成。字符串定义很简单，直接用双引号\"包含内容，被称为字符串字面量（string literal）。 en := \"hello go\" ch := \"你好，go\" Go字符串的内部实现是使用 UTF-8 编码，通过 rune 类型可以方便的访问每一个 UTF-8 字符，也支持按传统的 ASCII 码方式进行逐字符访问。 package main import ( \"fmt\" ) func main() { ch := \"你好，go\" for _, ch := range ch { fmt.Printf(\"%d - %c\\n\", rune(ch), ch) } } # 输出 20320 - 你 22909 - 好 65292 - ， 103 - g 111 - o 定义多行字符串 双引号定义的字符串不能跨行，要想跨行，可以使用反引号(`)定义，但是，所有的转义字符均无效，文本将会原样输出。 package main import ( \"fmt\" ) func main() { str := ` 你好 go ` fmt.Println(str) } 输出内容带有h1标签： 你好 go Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-05-22 15:25:28 "},"go/base/data/format.html":{"url":"go/base/data/format.html","title":"格式化输出","keywords":"","body":"官方文档：https://godoc.org/fmt 格式 含义 %% 一个%字面量 %b 一个二进制整数值(基数为2)，或者是一个(高级的)用科学计数法表示的指数为2的浮点数 %c 字符型。可以把输入的数字按照ASCII码相应转换为对应的字符 %d 一个十进制数值(基数为10) %e 以科学记数法e表示的浮点数或者复数值 %E 以科学记数法E表示的浮点数或者复数值 %f 以标准记数法表示的浮点数或者复数值 %g 以%e或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出 %G 以%E或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出 %o 一个以八进制表示的数字(基数为8) %p 以十六进制(基数为16)表示的一个值的地址，前缀为0x,字母使用小写的a-f表示 %q 使用Go语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字 %s 字符串。输出字符串中的字符直至字符串中的空字符（字符串以'\\0‘结尾，这个'\\0'即空字符） %t 以true或者false输出的布尔值 %T 使用Go语法输出的值的类型 %U 一个用Unicode表示法表示的整型码点，默认值为4个数字字符 %v 使用默认格式输出的内置或者自定义类型的值，或者是使用其类型的String()方式输出的自定义值，如果该方法存在的话 %x 以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示 %X 以十六进制表示的整型值(基数为十六)，数字A-F使用小写表示 通用： %v 值的默认格式表示。当输出结构体时，扩展标志（%+v）会添加字段名 %#v 值的Go语法表示 %T 值的类型的Go语法表示 %% 百分号 其它： + 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）； - 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）； # 切换格式： 八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）； 对%q（%#q），如果strconv.CanBackquote返回真会输出反引号括起来的未转义字符串； 对%U（%#U），如果字符是可打印的，会在输出Unicode格式、空格、单引号括起来的go字面值； ' ' 对数值，正数前加空格而负数前加负号； 对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格； 0 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面； Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-07-10 09:39:08 "},"go/base/data/conversion.html":{"url":"go/base/data/conversion.html","title":"数据类型转换","keywords":"","body":"超强类型 Go 是强类型语言，在类型约束方面甚至比 C 更严格，比如：在 C 中整型和浮点型可以运算，而在 Go 中是不允许的： C 语言代码： #include int main() { int a = 6; double b = 6.8; double sum; sum = a + b; printf(\"%d + %f = %f\", a, b, sum); } // 输出 6 + 6.800000 = 12.800000 Go 语言代码： package main import \"fmt\" func main() { var a int = 6 var b float64 = 6.8 var sum float64 sum = a + b // sum = float64(a) + b 显示转换后，这样是正确的 fmt.Println(sum) } // 输出 # command-line-arguments test/test21.go:10:10: invalid operation: a + b (mismatched types int and float64) 常见类型转换 除了常见的同类（数字、浮点等等）型之间的转换，如：int、int32、float32等等之外，还有就是跨类型的转换：字符串转为整型、整型转为字符串等等。 字符串数字常量转为数字 package main import ( \"fmt\" \"strconv\" \"unsafe\" ) func main() { s := \"68\" // string -> int a,_ := strconv.Atoi(s) // Atoi是ParseInt的简写 b,_ := strconv.ParseInt(s, 10, 0) // string -> int64 c,_ := strconv.ParseInt(s, 10, 64) // string -> uint d,_ := strconv.ParseUint(s, 10, 0) // string -> uint32 e,_ := strconv.ParseUint(s, 19, 32) // string -> float32 f,_ := strconv.ParseFloat(s, 32) // string -> float64 g,_ := strconv.ParseFloat(s, 64) // string -> bool h,_ := strconv.ParseBool(s) fmt.Printf(\"s = %s : type is %T, size of %d\\n\", s, s, unsafe.Sizeof(s)) fmt.Printf(\"a[string->int] = %d : type is %T, size of %d\\n\", a, a, unsafe.Sizeof(a)) fmt.Printf(\"b[string->int] = %d : type is %T, size of %d\\n\", b, b, unsafe.Sizeof(b)) fmt.Printf(\"c[string->int64] = %d : type is %T, size of %d\\n\", c, c, unsafe.Sizeof(c)) fmt.Printf(\"d[string->uint] = %d : type is %T, size of %d\\n\", d, d, unsafe.Sizeof(d)) fmt.Printf(\"e[string->uint32] = %d : type is %T, size of %d\\n\", e, e, unsafe.Sizeof(e)) fmt.Printf(\"f[string->float32] = %f : type is %T, size of %d\\n\", f, f, unsafe.Sizeof(f)) fmt.Printf(\"g[string->float64] = %f : type is %T, size of %d\\n\", g, g, unsafe.Sizeof(g)) fmt.Printf(\"h[string->bool] = %t : type is %T, size of %d\\n\\n\", h, h, unsafe.Sizeof(h)) } // 输出 s = 68 : type is string, size of 16 a[string->int] = 68 : type is int, size of 8 b[string->int] = 68 : type is int64, size of 8 c[string->int64] = 68 : type is int64, size of 8 d[string->uint] = 68 : type is uint64, size of 8 e[string->uint32] = 122 : type is uint64, size of 8 f[string->float32] = 68.000000 : type is float64, size of 8 g[string->float64] = 68.000000 : type is float64, size of 8 h[string->bool] = false : type is bool, size of 1 数字转为字符串 package main import ( \"fmt\" \"strconv\" \"unsafe\" ) func main() { i := 68 // int -> string j := strconv.Itoa(i) // int64 -> string k := int64(i) l := strconv.FormatInt(k, 10) // bool -> string m := true n := strconv.FormatBool(m) // uint -> string o := uint64(i) p := strconv.FormatUint(o,10) // float -> string r := 6.6 t := strconv.FormatFloat(r, 'E', -1, 64) fmt.Printf(\"i = %d : type is %T, size of %d\\n\", i, i, unsafe.Sizeof(i)) fmt.Printf(\"j[int->string] = %s : type is %T, size of %d\\n\", j, j, unsafe.Sizeof(j)) fmt.Printf(\"k[int->int64] = %d : type is %T, size of %d\\n\", k, k, unsafe.Sizeof(k)) fmt.Printf(\"l[int64->string] = %s : type is %T, size of %d\\n\", l, l, unsafe.Sizeof(l)) fmt.Printf(\"m = %t : type is %T, size of %d\\n\", m, m, unsafe.Sizeof(m)) fmt.Printf(\"n[bool->string] = %s : type is %T, size of %d\\n\", n, n, unsafe.Sizeof(n)) fmt.Printf(\"o = %d : type is %T, size of %d\\n\", o, o, unsafe.Sizeof(o)) fmt.Printf(\"p[uint64->string] = %s : type is %T, size of %d\\n\", p, p, unsafe.Sizeof(p)) fmt.Printf(\"r = %f : type is %T, size of %d\\n\", r, r, unsafe.Sizeof(r)) fmt.Printf(\"t[float->string] = %s : type is %T, size of %d\\n\", t, t, unsafe.Sizeof(t)) } // 输出 i = 68 : type is int, size of 8 j[int->string] = 68 : type is string, size of 16 k[int->int64] = 68 : type is int64, size of 8 l[int64->string] = 68 : type is string, size of 16 m = true : type is bool, size of 1 n[bool->string] = true : type is string, size of 16 o = 68 : type is uint64, size of 8 p[uint64->string] = 68 : type is string, size of 16 r = 6.600000 : type is float64, size of 8 t[float->string] = 6.6E+00 : type is string, size of 16 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-05-30 22:56:17 "},"go/package/":{"url":"go/package/","title":"包解析","keywords":"","body":"Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-06-26 09:29:22 "},"go/command/":{"url":"go/command/","title":"命令行工具","keywords":"","body":"Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-06-21 09:52:32 "},"go/command/mod.html":{"url":"go/command/mod.html","title":"管理工具-gomod","keywords":"","body":"依赖管理工具在开发过程中，给我们提供了很大方便，像是PHP的composer、Node的npm、Java的Maven和Gradle。 在 go1.11 版本中，增加了module管理功能，用来管理依赖包，model 取代了基于 GOPATH 方法来指定代码仓库的位置，允许将你的代码仓库放到GOPATH/src目录之外的任何地方，并且 go.mod 可以指定包的版本。 准备环境 代理 go mod的代理比较出名的有微软的athens，可以基于它搭建一个私有的代理，管理内部的私有代码，而且微软提供了一个公共的代理，我们可以直接使用 Linux export GOPROXY=\"https://athens.azurefd.net\" export GO111MODULE=on Windows 设置GOPROXY和GO111MODULE环境变量 这样google下的包可以顺利下载了,速度还挺快的。 小技巧 逃离GOPATH 毕竟有时候一个项目的代码可能使用多种语言，按照以前的方式，就非得把项目的代码都放在gopath下了，让我这种强迫症的人，很不爽。 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2019-06-27 09:20:40 "}}