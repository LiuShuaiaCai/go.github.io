{"./":{"url":"./","title":"资源列表","keywords":"","body":"下面是我在学习过程中参考前辈们的资料，谢谢大家分享的经验，如有侵权麻烦通知(liusweets@163.com)，会马上处理。 GO 文档 官方文档 https://golang.google.cn Go语言中文网 https://studygolang.com Go语言四十二章经 https://www.jianshu.com/nb/29056963 数据库 GORM中文文档 http://gorm.book.jasperxu.com Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-06-26 09:51:33 "},"go/variable/":{"url":"go/variable/","title":"变量","keywords":"","body":"变量定义 变量标识符由字母、数字、下划线组成 首个字母不能为数字 同一字母大小写也是不一样的 go语言中有25个关键字作为保留字，不能当作变量使用 break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 变量的四种声明方式 方法一：使用var关键字声明一个变量，默认值是0 var num int 方法二：声明一个变量，并初始化一个默认值 var num int = 1 方法三：变量初始化时，省去数据类型，通过初始化的值来自动匹配当前变量的数据类型 var num = 1 方法四：简写方式（常用），省去var关键字和数据类型，使用符号:=，直接自动匹配 num := 1 注：该方式只能在函数（方法）内部定义局部变量，不能定义全局变量 多变量声明 单行写法 var a, b int = 1, 2 var e, f = 3, \"f\" 多行写法 var ( gg int = 100 hh string = \"hello\" ii bool = true ) Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-02-16 14:56:32 "},"go/variable/type.html":{"url":"go/variable/type.html","title":"数据类型","keywords":"","body":"不论任何一种语言，都有数据类型的概念，我们常见的基本数据类型有：整型(int)、浮点型(float)、布尔型(bool)、字符串(string)。Go 除了几种基本类型外，还有指针(pointer)、数组(array)、结构体(struct)、通道(channel)、函数(func)、切片(slice)、接口(interface)、集合(map)。 下面是Go的几种基本数据类型的介绍 布尔型（bool） bool 类型表示一个布尔值，值为只有两种 true 或者 false。 package main import ( \"fmt\" \"unsafe\" ) func main() { var a bool = true var b bool = false fmt.Printf(\"a: type is %T, size is %d\\n\", a, unsafe.Sizeof(a)) fmt.Printf(\"b: type is %T, size is %d\", b, unsafe.Sizeof(b)) } // 输出 a: type is bool, size is 1 b: type is bool, size is 1 整型（int） 整型分为 有符号整型（int）和 无符号整型（uint） 类型 大小 范围 有符号整型 int8 8位 -128～127 int16 16位 -32768～32767 int32 32位 -2147483648～2147483647 int64 64位 -9223372036854775808～9223372036854775807 无符号整型 uint8 8位 0~255 uint16 16位 0～65535 uint32 32位 0～4294967295 uint64 64位 0～18446744073709551615 uint8 就是我们熟知的 byte 型，int16 对应C语言中的 short 型，int64 对应C语言中的 long 型。 int：根据不同的底层平台，表示 32 或 64 位整型。 uint：根据不同的底层平台，表示 32 或 64 位无符号整型。 byte 是 uint8 的别名，代表ASCII码的一个字符。 rune 是 int32 的别名，代表UTF-8字符，在处理中文、日文或其它复合字符时，需要使用rune类型。 package main import ( \"fmt\" \"unsafe\" ) func main() { var a int = -12 var b int8 = -88 var c uint = 12 var d uint8 = 88 fmt.Printf(\"a: type is %T, size is %d\\n\", a, unsafe.Sizeof(a)) fmt.Printf(\"b: type is %T, size is %d\\n\", b, unsafe.Sizeof(b)) fmt.Printf(\"c: type is %T, size is %d\\n\", c, unsafe.Sizeof(c)) fmt.Printf(\"d: type is %T, size is %d\\n\", d, unsafe.Sizeof(d)) } // 输出 a: type is int, size is 8 b: type is int8, size is 1 c: type is uint, size is 8 d: type is uint8, size is 1 浮点型（float） 浮点型分为 32位浮点型（float32）和 64位浮点型（float64），一般来说，CPU处理单精度浮点数的速度比处理双精度浮点数快。 类型 有效位数 常量 范围 字节数 float32 8位 最大值:math.MaxFloat32最小值:math.MinFloat32 -3.40E+38 ~ +3.40E+38 4个字节 float64 16位 最大值:math.MaxFloat64最小值:math.MinFloat64 -1.79E+308 ~ +1.79E+308 8个字节 package main import ( \"fmt\" \"unsafe\" ) func main() { var a float32 = 18.88 var b float64 = 18.88 var c = 18.88 fmt.Printf(\"a = %f: type is %T, size is %d\\n\", a, a, unsafe.Sizeof(a)) fmt.Printf(\"b = %f: type is %T, size is %d\\n\", b, b, unsafe.Sizeof(b)) fmt.Printf(\"c = %f: type is %T, size is %d\\n\", c, c, unsafe.Sizeof(c)) } // 输出 a = 18.879999: type is float32, size is 4 b = 18.880000: type is float64, size is 8 c = 18.880000: type is float64, size is 8 可以看出同一个小数，不同的精度输出值不同，当然，如果小数位数达到有效位数，会现实相同的值 复数型（complex） 复数型分为 64位（complex64）和 128位（complex128） 使用内建函数 complex 创建一个复数，complex 函数定义如下： func complex(r, i FloatType) ComplexType 第一个参数是实部，第二个参数是虚部，返回复数类型 实部和虚部的值应该是同种类型，float32 或者 float64 如果是float32，返回 complex64 类型的复数 如果是float64，返回 complex128 类型的复数 使用简短语法 var c complex64 = 6 + 8i 看一下这个例子，更容易理解一些 package main import ( \"fmt\" \"unsafe\" ) func main() { var a complex64 = 6 + 8i b := 6 + 8i d := complex(float32(6), 8) c := complex(6, 8) fmt.Printf(\"a = %G: type is %T, size is %d\\n\", a, a, unsafe.Sizeof(a)) fmt.Printf(\"b = %G: type is %T, size is %d\\n\", b, b, unsafe.Sizeof(b)) fmt.Printf(\"c = %G: type is %T, size is %d\\n\", c, c, unsafe.Sizeof(c)) fmt.Printf(\"d = %G: type is %T, size is %d\\n\", d, d, unsafe.Sizeof(d)) } // 输出 a = (6+8i): type is complex64, size is 8 b = (6+8i): type is complex128, size is 16 c = (6+8i): type is complex128, size is 16 d = (6+8i): type is complex64, size is 8 字符串（string） 字符串不可修改，定义字符串有两种方法，具体如下： 方法一：使用双引号\"包含内容，其中转义字符会被转换，不能跨行 en := \"hello go\" ch := \"你好，go\" Go字符串的内部实现是使用 UTF-8 编码，通过 rune 类型可以方便的访问每一个 UTF-8 字符，也支持按传统的 ASCII 码方式进行逐字符访问。 package main import ( \"fmt\" ) func main() { ch := \"你好，go\" for _, ch := range ch { fmt.Printf(\"%d - %c\\n\", rune(ch), ch) } } # 输出 20320 - 你 22909 - 好 65292 - ， 103 - g 111 - o 方法二：使用反引号(`)定义，文本将会原样输出，可以跨行 package main import ( \"fmt\" ) func main() { str := ` 你好 go ` fmt.Println(str) } 输出内容带有h1标签： 你好 go 获取字符串长度 如果字符串是纯字母组成可使用len()获取字符串长度，如果含有中文等类型可用unicode/utf8包中的RuneCountInString()方法获取长度。 package main import ( \"fmt\" \"unicode/utf8\" ) func main() { s := \"你好，world\" fmt.Println(len(s)) // 14 fmt.Println(utf8.RuneCountInString(s)) // 8 } 字符串拼接 方法一：直接使用+运算符 var s string s += \"姓名：刘帅才\\n\" s += \"年龄：18\\n\" s += \"籍贯：河南\" 方法二：fmt拼接 func StringFmt() string { return fmt.Sprintf(\"%s:%s\\n%s:%s\\n%s:%s\", \"姓名\", \"刘帅才\", \"年龄\", \"18\", \"籍贯\", \"河南\") } 方法三：Join拼接 func StringJoin() string { s := []string{\"姓名\", \":\", \"刘帅才\", \"\\n\", \"年龄\", \":\", \"18\", \"\\n\", \"籍贯\", \":\", \"河南\"} return strings.Join(s, \"\") } 方法四：Buffer拼接 func StringBuffer() string { var b bytes.Buffer b.WriteString(\"姓名\") b.WriteString(\":\") b.WriteString(\"刘帅才\") b.WriteString(\"\\n\") b.WriteString(\"年龄\") b.WriteString(\":\") b.WriteString(\"18\") b.WriteString(\"\\n\") b.WriteString(\"籍贯\") b.WriteString(\":\") b.WriteString(\"河南\") return b.String() } 方法五：Builder拼接 func StringBuilder() string { var b strings.Builder b.WriteString(\"姓名\") b.WriteString(\":\") b.WriteString(\"刘帅才\") b.WriteString(\"\\n\") b.WriteString(\"年龄\") b.WriteString(\":\") b.WriteString(\"18\") b.WriteString(\"\\n\") b.WriteString(\"籍贯\") b.WriteString(\":\") b.WriteString(\"河南\") return b.String() } 性能对比 func BenchmarkStringPlus(b *testing.B) { for i := 0; i 压测结果如下（每次操作时长、每次操作分配内存、每次操作分配内存次数）： $ go test -bench=. -benchtime=3s -benchmem goos: darwin goarch: amd64 pkg: study/test cpu: Intel(R) Core(TM) i5-7360U CPU @ 2.30GHz BenchmarkStringPlus-4 36411696 110.3 ns/op 80 B/op 2 allocs/op BenchmarkStringFmt-4 17874686 238.2 ns/op 48 B/op 1 allocs/op BenchmarkStringJoin-4 24533844 137.7 ns/op 48 B/op 1 allocs/op BenchmarkStringBuffer-4 26626983 123.2 ns/op 112 B/op 2 allocs/op BenchmarkStringBuilder-4 23597000 155.9 ns/op 120 B/op 4 allocs/op PASS ok study/test 28.506s 从上面的结果可以看出，除了fmt拼接外，其它几个也都差不多，可能会因为字符串的长短，结果可能也会不同，可以具体情况进行压测选择 string的标准库 库名 说明 strings 提供了许多字符串的查询、替换、比较、截断、拆分、合并功能 bytes 也提供了很多strings包类似的功能，对字符串的修改更高效 strconv 提供了布尔型、整数型、浮点数和对应字符串的转换，还提供了双引号转义相关转换 unicode 提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-01-28 08:40:53 "},"go/variable/format.html":{"url":"go/variable/format.html","title":"格式化输出","keywords":"","body":"官方文档：https://godoc.org/fmt 格式 含义 %% 一个%字面量 %b 一个二进制整数值(基数为2)，或者是一个(高级的)用科学计数法表示的指数为2的浮点数 %c 字符型。可以把输入的数字按照ASCII码相应转换为对应的字符 %d 一个十进制数值(基数为10) %e 以科学记数法e表示的浮点数或者复数值 %E 以科学记数法E表示的浮点数或者复数值 %f 以标准记数法表示的浮点数或者复数值 %g 以%e或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出 %G 以%E或者%f表示的浮点数或者复数，任何一个都以最为紧凑的方式输出 %o 一个以八进制表示的数字(基数为8) %p 以十六进制(基数为16)表示的一个值的地址，前缀为0x,字母使用小写的a-f表示 %q 使用Go语法以及必须时使用转义，以双引号括起来的字符串或者字节切片[]byte，或者是以单引号括起来的数字 %s 字符串。输出字符串中的字符直至字符串中的空字符（字符串以'\\0‘结尾，这个'\\0'即空字符） %t 以true或者false输出的布尔值 %T 使用Go语法输出的值的类型 %U 一个用Unicode表示法表示的整型码点，默认值为4个数字字符 %v 使用默认格式输出的内置或者自定义类型的值，或者是使用其类型的String()方式输出的自定义值，如果该方法存在的话 %x 以十六进制表示的整型值(基数为十六)，数字a-f使用小写表示 %X 以十六进制表示的整型值(基数为十六)，数字A-F使用小写表示 通用： %v 值的默认格式表示。当输出结构体时，扩展标志（%+v）会添加字段名 %#v 值的Go语法表示 %T 值的类型的Go语法表示 %% 百分号 其它： + 总是输出数值的正负号；对%q（%+q）会生成全部是ASCII字符的输出（通过转义）； - 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）； # 切换格式： 八进制数前加0（%#o），十六进制数前加0x（%#x）或0X（%#X），指针去掉前面的0x（%#p）； 对%q（%#q），如果strconv.CanBackquote返回真会输出反引号括起来的未转义字符串； 对%U（%#U），如果字符是可打印的，会在输出Unicode格式、空格、单引号括起来的go字面值； ' ' 对数值，正数前加空格而负数前加负号； 对字符串采用%x或%X时（% x或% X）会给各打印的字节之间加空格； 0 使用0而不是空格填充，对于数值类型会把填充的0放在正负号后面； Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-01-27 10:05:41 "},"go/variable/conversion.html":{"url":"go/variable/conversion.html","title":"数据类型转换","keywords":"","body":"超强类型 Go 是强类型语言，在类型约束方面甚至比 C 更严格，比如：在 C 中整型和浮点型可以运算，而在 Go 中是不允许的： C 语言代码： #include int main() { int a = 6; double b = 6.8; double sum; sum = a + b; printf(\"%d + %f = %f\", a, b, sum); } // 输出 6 + 6.800000 = 12.800000 Go 语言代码： package main import \"fmt\" func main() { var a int = 6 var b float64 = 6.8 var sum float64 sum = a + b // sum = float64(a) + b 显示转换后，这样是正确的 fmt.Println(sum) } // 输出 # command-line-arguments test/test21.go:10:10: invalid operation: a + b (mismatched types int and float64) 常见类型转换 除了常见的同类（数字、浮点等等）型之间的转换，如：int、int32、float32等等之外，还有就是跨类型的转换：字符串转为整型、整型转为字符串等等。 字符串数字常量转为数字 package main import ( \"fmt\" \"strconv\" \"unsafe\" ) func main() { s := \"68\" // string -> int a,_ := strconv.Atoi(s) // Atoi是ParseInt的简写 b,_ := strconv.ParseInt(s, 10, 0) // string -> int64 c,_ := strconv.ParseInt(s, 10, 64) // string -> uint d,_ := strconv.ParseUint(s, 10, 0) // string -> uint32 e,_ := strconv.ParseUint(s, 19, 32) // string -> float32 f,_ := strconv.ParseFloat(s, 32) // string -> float64 g,_ := strconv.ParseFloat(s, 64) // string -> bool h,_ := strconv.ParseBool(s) fmt.Printf(\"s = %s : type is %T, size of %d\\n\", s, s, unsafe.Sizeof(s)) fmt.Printf(\"a[string->int] = %d : type is %T, size of %d\\n\", a, a, unsafe.Sizeof(a)) fmt.Printf(\"b[string->int] = %d : type is %T, size of %d\\n\", b, b, unsafe.Sizeof(b)) fmt.Printf(\"c[string->int64] = %d : type is %T, size of %d\\n\", c, c, unsafe.Sizeof(c)) fmt.Printf(\"d[string->uint] = %d : type is %T, size of %d\\n\", d, d, unsafe.Sizeof(d)) fmt.Printf(\"e[string->uint32] = %d : type is %T, size of %d\\n\", e, e, unsafe.Sizeof(e)) fmt.Printf(\"f[string->float32] = %f : type is %T, size of %d\\n\", f, f, unsafe.Sizeof(f)) fmt.Printf(\"g[string->float64] = %f : type is %T, size of %d\\n\", g, g, unsafe.Sizeof(g)) fmt.Printf(\"h[string->bool] = %t : type is %T, size of %d\\n\\n\", h, h, unsafe.Sizeof(h)) } // 输出 s = 68 : type is string, size of 16 a[string->int] = 68 : type is int, size of 8 b[string->int] = 68 : type is int64, size of 8 c[string->int64] = 68 : type is int64, size of 8 d[string->uint] = 68 : type is uint64, size of 8 e[string->uint32] = 122 : type is uint64, size of 8 f[string->float32] = 68.000000 : type is float64, size of 8 g[string->float64] = 68.000000 : type is float64, size of 8 h[string->bool] = false : type is bool, size of 1 数字转为字符串 package main import ( \"fmt\" \"strconv\" \"unsafe\" ) func main() { i := 68 // int -> string j := strconv.Itoa(i) // int64 -> string k := int64(i) l := strconv.FormatInt(k, 10) // bool -> string m := true n := strconv.FormatBool(m) // uint -> string o := uint64(i) p := strconv.FormatUint(o,10) // float -> string r := 6.6 t := strconv.FormatFloat(r, 'E', -1, 64) fmt.Printf(\"i = %d : type is %T, size of %d\\n\", i, i, unsafe.Sizeof(i)) fmt.Printf(\"j[int->string] = %s : type is %T, size of %d\\n\", j, j, unsafe.Sizeof(j)) fmt.Printf(\"k[int->int64] = %d : type is %T, size of %d\\n\", k, k, unsafe.Sizeof(k)) fmt.Printf(\"l[int64->string] = %s : type is %T, size of %d\\n\", l, l, unsafe.Sizeof(l)) fmt.Printf(\"m = %t : type is %T, size of %d\\n\", m, m, unsafe.Sizeof(m)) fmt.Printf(\"n[bool->string] = %s : type is %T, size of %d\\n\", n, n, unsafe.Sizeof(n)) fmt.Printf(\"o = %d : type is %T, size of %d\\n\", o, o, unsafe.Sizeof(o)) fmt.Printf(\"p[uint64->string] = %s : type is %T, size of %d\\n\", p, p, unsafe.Sizeof(p)) fmt.Printf(\"r = %f : type is %T, size of %d\\n\", r, r, unsafe.Sizeof(r)) fmt.Printf(\"t[float->string] = %s : type is %T, size of %d\\n\", t, t, unsafe.Sizeof(t)) } // 输出 i = 68 : type is int, size of 8 j[int->string] = 68 : type is string, size of 16 k[int->int64] = 68 : type is int64, size of 8 l[int64->string] = 68 : type is string, size of 16 m = true : type is bool, size of 1 n[bool->string] = true : type is string, size of 16 o = 68 : type is uint64, size of 8 p[uint64->string] = 68 : type is string, size of 16 r = 6.600000 : type is float64, size of 8 t[float->string] = 6.6E+00 : type is string, size of 16 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-01-27 10:05:41 "},"go/constant.html":{"url":"go/constant.html","title":"常量","keywords":"","body":"常量的定义 定义常量使用const关键字，用于存储一些不会改变的数据。常量支持的数据类型：布尔型（bool）、数字型（整数[int]、浮点数[float]、复数[complex]）和字符串型（string）。 定义格式：const identifier [type] = value，例如： const NAME string = \"Lsc\" 定义常量的类型（type）可以省略，会根据上下文来获得相关的类型，和字面常量一样,称为无类型（untyped）常量。 字面常量（literal），是指程序中硬编码的常量，如：-12。它们的值即为它们本身，是无法被改变的。 常量表达式 常量定义也可以是常量表达式: const AA = 2.6 * 3 + 6 const AB = \"a\" + \"b\" 但是表达式中不能含有变量，例如： // 这样不正确 var b = 2.6 const BB = 2.6 * 3 + b 也不能是函数，例如 var a = math.Sqrt(4) // 允许 const BB = math.Sqrt(4) // 不允许 预定义常量 Go预定义的一些常量：true、false、iota，true和false是布尔常量，而iota比较特殊，可以认为是一个能被编译器修改的常量。一个 const 声明内的每一行常量声明，将会自动套用前面的 iota 格式，并自动增加1，即使被中断，恢复后接着当前常量位置（索引）的继续递增，看下面的例子： package main import ( \"fmt\" ) func main() { const ( AA = iota // 0 BB // 1 CC // 2 DD = 8 // 3 ，这里被中断，之后的常量如果没有初始化，也是等于改值，即：EE = 8, FF = 8 EE // 4 FF // 5 GG = iota // 6 ，这里又恢复为iota，即 GG = 6, HH = 7 HH // 7 ) fmt.Println(AA,BB,CC,EE,FF,GG,HH) } // 输出 0 1 2 8 8 8 6 7 实例：将枚举值转化为字符串 下面是根据枚举值显示相应的字符串，参考文章：http://c.biancheng.net/view/24.html package main import ( \"fmt\" ) // 声明语言的类型 type LanguageType int // 定义类型常量 const ( None LanguageType = iota Go PHP Python ) // 定义一个字符串函数 func (l LanguageType) String() string { switch l { case None: return \"None\" case Go: return \"Go\" case PHP: return \"PHP\" case Python: return \"Python\" } return \"N/A\" } func main() { // 输出Go的值并以整型格式显示 fmt.Printf(\"%s %d\\n\", None, None) fmt.Printf(\"%s %d\\n\", Go, Go) fmt.Printf(\"%s %d\\n\", Python, Python) } // 输出 None 0 Go 1 Python 3 使用 String() 方法的 LanguageType 在使用上和普通的常量没有区别。当这个类型需要显示为字符串时，Go 语言会自动寻找 String() 方法并进行调用。 总结 常量定义之后不能修改 常量可以定义后不使用，而变量定义后必须使用 常量的值必须是能够在编译时就能够确定的，不能是变量或者函数 在分配过程中不允许有混合类型 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-02-16 14:57:09 "},"go/array.html":{"url":"go/array.html","title":"数组(array)","keywords":"","body":"特点 元素类型相同 长度固定，不可以追加元素 长度、类型不同的变量不能比较 数组初始化 a)指定长度 a := [2]int{1, 2} b)不指定长度 不指定长度时，其长度是由后面初始化列表数量来确定。 a := [...]int{1,2} c)定义多维数组 a := [2][8]int{{6, 8}} // [[6 8 0 0 0 0 0 0] [0 0 0 0 0 0 0 0]] 数组遍历 package main import \"fmt\" func main() { a := [...]string{\"liu\", \"shuai\", \"cai\"} // 方法一 for i := 0; i Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-02-16 14:56:06 "},"go/slice.html":{"url":"go/slice.html","title":"切片(slice)","keywords":"","body":" 切片是对底层数组一个连续片段的引用，所以切片是一个引用类型 为初始化的切片的值为nil，长度为0，容量为0 使用内置函数make()给切片初始化var slice1 []type = make([]type, len,cap) len值不能比cap值大 创建切片时可跟据实际需要预分配容量,尽量避免追加过程中扩容操作,有利于提升性能 谨慎使用多个切片操作同一个数组,以防读写冲突 slice数据结构 源码包src/runtime/slice.go:slice中定义了slice的数据结构，如下： type slice struct { array unsafe.Pointer // 指向一个数组元素的地址 len int // 长度 cap int // 底层数组的容量 } 切片初始化 a) 从数组或者切片中生成一个新的切片 a[low : high : max] max-low的结果表示容量，high-low的结果表示长度 arr := [8]int{1, 2, 3, 4, 5, 6, 7, 8} s := arr[1:3] // s=[2 3], len=2, cap=7 // s := arr[1:3:6] // s=[2 3], len=2, cap=5 变量结构如下图所示： GDB调试如下： b) 通过内置函数make创建 // len=10, cap=10 a := make([]int, 10) // len=8, cap=10 b := make([]int, 8, 10) 切片操作 函数 说明 len 获取切片长度 cap 获取切片底层数组容量 append 对切片追加元素 copy 复制一个切片 添加多个元素 a := []string{\"hello\"} // [hello] a = append(a, \"liu\", \"shuai\") // [hello liu shuai] 把一个切片内容添加到当前切片 b := []string{\"cai\", \"ye\"} a = append(a, b...) // [hello liu shuai cai ye] 将字符串附加到字节片 s := append([]byte(\"hello \"), \"world\"...) // hello world 切片扩容 扩容判断流程如下（/usr/local/go/src/runtime/slice.go:growslice）： 4.1、不需要扩容 s := make([]int, 1, 2) fmt.Printf(\"len=%d, cap=%d, address=%x \\n\", len(s), cap(s), *(*uintptr)(unsafe.Pointer(&s))) // len=1, cap=2, address=c00005ced8 s = append(s, 1) fmt.Printf(\"len=%d, cap=%d, address=%x \\n\", len(s), cap(s), *(*uintptr)(unsafe.Pointer(&s))) // len=2, cap=2, address=c00005ced8 4.2、如果期望容量大于当前容量的两倍就会使用期望容量 s := make([]int, 1, 2) fmt.Printf(\"len=%d, cap=%d, address=%x \\n\", len(s), cap(s), *(*uintptr)(unsafe.Pointer(&s))) // len=1, cap=2, address=c00005ced8 s = append(s, 1, 2, 3, 4) fmt.Printf(\"len=%d, cap=%d, address=%x \\n\", len(s), cap(s), *(*uintptr)(unsafe.Pointer(&s))) // len=5, cap=6, address=c00001a180 4.3、如果当前切片的长度小于 1024 就会将容量翻倍 s := make([]int, 6, 8) fmt.Printf(\"len=%d, cap=%d, address=%x \\n\", len(s), cap(s), *(*uintptr)(unsafe.Pointer(&s))) // len=6, cap=8, address=c000092ea8 s = append(s, 1, 2, 3) fmt.Printf(\"len=%d, cap=%d, address=%x \\n\", len(s), cap(s), *(*uintptr)(unsafe.Pointer(&s))) // len=9, cap=16, address=c0000ba000 4.4、如果当前切片的长度大于 1024 就会每次增加 1/4 的容量，直到新容量大于期望容量 s := make([]int, 1024) fmt.Printf(\"len=%d, cap=%d, address=%x \\n\", len(s), cap(s), *(*uintptr)(unsafe.Pointer(&s))) // len=1024, cap=1024, address=c000075ee8 s = append(s, 1) fmt.Printf(\"len=%d, cap=%d, address=%x \\n\", len(s), cap(s), *(*uintptr)(unsafe.Pointer(&s))) // len=1025, cap=1280, address=c000100000 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-02-16 15:05:02 "},"go/map.html":{"url":"go/map.html","title":"字典(map)","keywords":"","body":" map是无序集合 map是引用类型 为初始化的map值为nil key 可以是任意可以用 == 或者 != 操作符比较的类型，比如 string、int、float、指针、接口类型。所以数组、函数、字典、切片和结构体不能作为key(含有数组切片的结构体不能作为key，只包含内建类型的struct是可以作为key的） map数据结构 map底层数据结构使用哈希表，并使用链表查找法解决冲突，一个哈希表里可以有多个哈希表结点（bucket），每个bucket保存了一个或者一组键值对。 map数据结构由/usr/local/go/src/runtime/map.go:hmap定义 type hmap struct { count int // 当前保存元素的个数，必须放在struct的第一个位置，因为内置的len函数会通过unsafe.Pointer会从这里读取 flags uint8 B uint8 // bucket的数量是2^B, 最多可以放 loadFactor * 2^B 个元素，再多就要 hashGrow 了 noverflow uint16 // 溢出桶的大致数量 hash0 uint32 // 散列种子 buckets unsafe.Pointer // bucket数组指针，数组大小为2^B，如果count=0，则为nil oldbuckets unsafe.Pointer // 旧的桶数组指针，只有在扩容时为非空 nevacuate uintptr // 扩容进度，记录下一个要迁移的旧桶编号 extra *mapextra // 当key和value都可以内联的时候，就会用到这个字段 } mapextra数据结构，存储溢出桶信息 type mapextra struct { overflow *[]*bmap // 当前已经使用的溢出桶地址 oldoverflow *[]*bmap // 扩容时，旧桶使用的溢出桶地址 nextOverflow *bmap // 下一个空闲的溢出桶地址 } 什么时候能用到mapextra? 当key和value不包含指针，并且是内联(inline)的，并且 bucket数据结构由/usr/local/go/src/runtime/map.go:bmap定义 type bmap struct { tophash [bucketCnt]uint8 // 每个元素hash值的高8位，如果tophash[0] 使用拉链法实现桶之间的串联：新桶优先使用预分配的桶 哈希高8位优化桶查找key：将key哈希值的高8位存储在桶的tohash数组中，这样查找时不用比较完整的key就能过滤掉不符合要求的key，tohash中的值相等，再去比较key值 桶中key/value分开存放：桶中所有的key存一起，所有的value存一起，目的是为了方便内存对齐 根据k/v大小存储不同值：当k或v大于128字节时，其存储的字段为指针，指向k或v的实际内容，小于等于128字节，其存储的字段为原值 桶的搬迁状态：可以根据tohash字段的值，是否小于minTopHash，来表示桶是否处于搬迁状态 整体结构如下图所示： 初始化 map的初始化方式有两种，例如 m := map[k]v{} m := make(map[k]v) m := make(map[k]v, hint) // 指定初始化map大小为hint 方法一：先声明再初始化 var m1 map[string]string m1 = make(map[string]string) m1[\"name\"] = \"lsc\" m1[\"age\"] = \"28\" 方法二：直接初始化 m1 := make(map[string]string) m1[\"name\"] = \"lsc\" m1[\"age\"] = \"28\" 方法三：直接赋值 m1 := map[string]string{ \"name\": \"lsc\", \"age\": \"28\", } map的创建过程 源码创建map的方法有三种： func makemap64(t *maptype, hint int64, h *hmap) *hmap func makemap_small() *hmap func makemap(t *maptype, hint int, h *hmap) *hmap 当 hint hash值定位 不同类型的key，会使用不一样的hash算法，由src/runtime/alg.go:typehash函数定义 hash := t.hasher(key, uintptr(h.hash0)) 通过hash值的定位流程如下： 通过低B位定位到所在桶（bucket）位置 再通过高8位定位在bucket的哪个位置 看下面这个例子，在map中查找key1的值 func main() { m := make(map[string]string, 120) for i := 0; i 具体流程如下： 查找过程 - mapaccess 查找函数有三种，具体如下： func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer) 使用形式v := m[k]时会调用函数mapaccess1 使用形式v,ok := m[k]时会调用函数mapaccess2 遍历map时会调用函数mapaccessK 根据key的类型调用不同的函数，不过基本逻辑都差不多，mapaccess1的过程如下： 源码如下： func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { // 是否开启竞态检测 -race if raceenabled && h != nil { callerpc := getcallerpc() pc := funcPC(mapaccess1) racereadpc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) } // 是否开启内存扫描 -msan if msanenabled && h != nil { msanread(key, t.key.size) } // 如果hmap为空或者元素个数为0，返回零值 if h == nil || h.count == 0 { if t.hashMightPanic() { t.hasher(key, 0) // see issue 23734 } return unsafe.Pointer(&zeroVal[0]) } // 当h.flags对应的值为hashWriting（表明有其余goroutine正在往map中写key）时，则会抛错误。 // 这也表示，go的map是非并发安全的 if h.flags&hashWriting != 0 { throw(\"concurrent map read and map write\") } // 不同类型的key，会使用不一样的hash算法，由```src/runtime/alg.go:typehash```函数定义 hash := t.hasher(key, uintptr(h.hash0)) // 根据hash值找到对应的bucket m := bucketMask(h.B) b := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize))) // 如果oldbuckets不为空，说明map发生了扩容 // 如果发生了扩容，可能有部分数据还没有迁移完成，所以要先查找的老的buckets if c := h.oldbuckets; c != nil { // 是否扩容到oldbuckets的2倍 if !h.sameSizeGrow() { m >>= 1 } // 在老的buckets找到对应的bucket oldb := (*bmap)(add(c, (hash&m)*uintptr(t.bucketsize))) // 判断迁移是否完成，只有没有迁移完成时，才使用oldbucket if !evacuated(oldb) { b = oldb } } // 取出当前key值的tophash值 top := tophash(hash) // 双层循环遍历：外层循环是从桶到溢出桶遍历；内层是桶中的cell遍历 // 跳出循环的条件有三种：第一种是已经找到key值；第二种是当前桶再无溢出桶； // 第三种是当前桶中有cell位的tophash值是emptyRest，这个值在前面解释过，它表明此时的桶后面的cell还未利用，因此无需再继续遍历。 bucketloop: for ; b != nil; b = b.overflow(t) { for i := uintptr(0); i 分配过程 - mapassign 按照不同类型，分配也分为3种 func mapassign_faststr(t *maptype, h *hmap, s string) unsafe.Pointer func mapassign_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer func mapassign_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer 各种类型的逻辑都差不多，mapassign的逻辑如下： func mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer { // 若是h是空指针，赋值会引发panic // 例如： // var m map[string]string // m[\"name\"] = \"lsc\" if h == nil { panic(plainError(\"assignment to entry in nil map\")) } // 是否开启竞态检测 -race if raceenabled { callerpc := getcallerpc() pc := funcPC(mapassign) racewritepc(unsafe.Pointer(h), callerpc, pc) raceReadObjectPC(t.key, key, callerpc, pc) } // 是否开启内存扫描 -msan if msanenabled { msanread(key, t.key.size) } // 是否有并发写入 if h.flags&hashWriting != 0 { throw(\"concurrent map writes\") } // 计算hash值 hash := t.hasher(key, uintptr(h.hash0)) // 在调用t.hasher之后设置hashWriting，我们实际上还没有完成写操作，再次调用t.hasher可能会发生painc // 开启屏障写 h.flags ^= hashWriting if h.buckets == nil { h.buckets = newobject(t.bucket) // newarray(t.bucket, 1) } again: // 计算应该存在第几个桶 bucket := hash & bucketMask(h.B) // 如果map数据正在迁移，则先要进行迁移 if h.growing() { growWork(t, h, bucket) } // 确定bucket桶的内存位置 b := (*bmap)(add(h.buckets, bucket*uintptr(t.bucketsize))) // 计算哈希值的高八位，即确定在当前桶的位置，字段tophash字段的值 top := tophash(hash) var inserti *uint8 var insertk unsafe.Pointer var elem unsafe.Pointer bucketloop: // 遍历 for { // 遍历桶中的8个cell for i := uintptr(0); i 6.5或者溢出桶的数量过多，则进行扩容 if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) { hashGrow(t, h) // hashGrow()实际并未完成扩容，对哈希表数据的迁移操做是由growWork()来完成的。 // 从新跳入again逻辑，在进行完growWork()操做后，再次遍历新的桶。 goto again } // 为当前桶再新建溢出桶，并将tophash，key插入到新建溢出桶的对应内存的0号位置 if inserti == nil { newb := h.newoverflow(t, b) inserti = &newb.tophash[0] insertk = add(unsafe.Pointer(newb), dataOffset) elem = add(insertk, bucketCnt*uintptr(t.keysize)) } // 将新的key、value存入插入位置 if t.indirectkey() { kmem := newobject(t.key) *(*unsafe.Pointer)(insertk) = kmem insertk = kmem } if t.indirectelem() { vmem := newobject(t.elem) *(*unsafe.Pointer)(elem) = vmem } typedmemmove(t.key, insertk, key) *inserti = top // key的数量加1 h.count++ done: if h.flags&hashWriting == 0 { throw(\"concurrent map writes\") } // 解除写保护 h.flags &^= hashWriting if t.indirectelem() { elem = *((*unsafe.Pointer)(elem)) } return elem } 从上面的分析可以看到，mapassign函数并没有把value写入对应的位置，只是返回了value的地址，这是因为将值拷贝到内存区域是通过底层汇编配合完成的，例如： func main() { m := make(map[string]int) m[\"a\"] = 88 } m[\"a\"] = 88 汇编代码如下： 0x0089 00137 (map5.go:6) LEAQ type.map[string]int(SB), AX 0x0090 00144 (map5.go:6) LEAQ \"\"..autotmp_1+32(SP), BX 0x0095 00149 (map5.go:6) LEAQ go.string.\"a\"(SB), CX 0x009c 00156 (map5.go:6) MOVL $1, DI 0x00a1 00161 (map5.go:6) PCDATA $1, $0 0x00a1 00161 (map5.go:6) CALL runtime.mapassign_faststr(SB) // 调用分配函数 0x00a6 00166 (map5.go:6) MOVQ $88, (AX) // 将88放入地址 扩容过程 6.1 什么时候扩容 在了解扩容的时候，肯定会想到这个什么时候扩容??? // 如果在所有桶中都没有找到key，进行下面的操作 // 负载因子 = count/2^B // 如果负载因子>6.5或者溢出桶的数量过多，则进行扩容 if !h.growing() && (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) { hashGrow(t, h) // hashGrow()实际并未完成扩容，对哈希表数据的迁移操做是由growWork()来完成的。 // 从新跳入again逻辑，在进行完growWork()操做后，再次遍历新的桶。 goto again } 原因一：负载因子>6.5 负载因子 = count/2^B 当负载因子>6.5时，说明大部分桶可能都快满了，如插入新的元素，就会有很大的概率挂在溢出桶上。 func overLoadFactor(count int, B uint8) bool { return count > bucketCnt && uintptr(count) > loadFactorNum*(bucketShift(B)/loadFactorDen) } 原因二：溢出桶的数量过多 判断溢出桶是否过多的方式有两种： 1、当常规桶的总数>=2^15时，如果溢出桶的数量>=2^15，则认为溢出桶太多了。 2、当常规桶的总数=常规桶总数，则认为溢出桶太多了。 func tooManyOverflowBuckets(noverflow uint16, B uint8) bool { if B > 15 { B = 15 } return noverflow >= uint16(1) 扩容规则 在扩容的时候采用的是增量扩容的方式，而不是全量扩容。 如果采取全量扩容，当前hmap很大，会花费大量的时间和内存，会导致系统卡顿，最直观的表现就是很慢。所以采用增量扩容，在hmap结构中有buckets、oldbuckets和nevacuate字段的设计方式，通过每一次操作进行渐进式扩容。 扩容规则如下： 翻倍扩容：扩容到旧桶数目的2倍 等量扩容：创建和旧桶数目一样多的新桶，把原来的数据迁移到新桶中。 为什么要有等量迁移？我们可以想一下，桶的负载因子没有超过上限值，却又这么多的溢出桶？这肯定是因为很多的键值对已经被删除。 源码如下： 源码分为两个部分：1、申请新桶-hashGrow，2、数据迁移-growWork func hashGrow(t *maptype, h *hmap) { // 如果超过负载因子，就使用翻倍扩容，否则采用等量扩容 bigger := uint8(1) if !overLoadFactor(h.count+1, h.B) { bigger = 0 h.flags |= sameSizeGrow } oldbuckets := h.buckets // 申请新的buckets newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil) flags := h.flags &^ (iterator | oldIterator) if h.flags&iterator != 0 { flags |= oldIterator } // hmap字段重新赋值 h.B += bigger h.flags = flags h.oldbuckets = oldbuckets h.buckets = newbuckets h.nevacuate = 0 h.noverflow = 0 if h.extra != nil && h.extra.overflow != nil { // Promote current overflow buckets to the old generation. if h.extra.oldoverflow != nil { throw(\"oldoverflow is not nil\") } h.extra.oldoverflow = h.extra.overflow h.extra.overflow = nil } if nextOverflow != nil { if h.extra == nil { h.extra = new(mapextra) } h.extra.nextOverflow = nextOverflow } // the actual copying of the hash table data is done incrementally // by growWork() and evacuate(). } func growWork(t *maptype, h *hmap, bucket uintptr) { // 迁移老的bucket evacuate(t, h, bucket&h.oldbucketmask()) // 如果未完成扩容动作，就继续迁移下一个bucket的数据 if h.growing() { evacuate(t, h, h.nevacuate) } } 迁移的核心逻辑 func evacuate(t *maptype, h *hmap, oldbucket uintptr) { // 计算老的bucket地址 b := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize))) // 表示老的buckets数量 1 newbit { stop = newbit } // 计算搬迁完成的桶数 for h.nevacuate != stop && bucketEvacuated(t, h, h.nevacuate) { h.nevacuate++ } // 如果h.nevacuate == newbit，则表明全部的桶都已经搬迁完毕 if h.nevacuate == newbit { // newbit == # of oldbuckets // 释放该桶 h.oldbuckets = nil if h.extra != nil { h.extra.oldoverflow = nil } h.flags &^= sameSizeGrow } } 参考文章 全面解析Golang之map设计 深入理解 Go map：赋值和扩容迁移 Golang底层原理剖析之map Golang map底层实现原理解析 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-02-16 15:10:32 "},"go/channel.html":{"url":"go/channel.html","title":"管道(channel)","keywords":"","body":" goroutine之间的通信方式 先进先出，保证收发数据的顺序 channel的数据结构 channel的数据结构由src/runtime/chan.go:hchan定义。 type hchan struct { qcount uint // 队列中元素的个数 dataqsiz uint // 环形队列的大小，初始化缓冲类型channel的设置 buf unsafe.Pointer // 环形队列存放数据的数组指针 elemsize uint16 // 每个元素的大小 closed uint32 // 关闭状态的标示 elemtype *_type // 元素的类型 sendx uint // 元素写入时存放队列中的位置 recvx uint // 队列中读取元素的位置 recvq waitq // 等待读消息的goroutine的队列 sendq waitq // 等待写消息的goroutine的队列 //锁保护hchan中的所有字段，以及该通道上被屏蔽的sudogs中的几个字段。 lock mutex // 互斥锁，chan不允许并发读写 } // 等待队列的数据结构 type waitq struct { first *sudog // 队列中的第一个g last *sudog // 队列中的最后一个g } sudog表示等待列表中的g，例如在通道上发送/接收，由src/runtime/runtime2.go:sudog定义，其结构如下： type sudog struct { g *g // goroutine指针 next *sudog // 下一个g prev *sudog // 上一个g elem unsafe.Pointer // 数据元素，可能在堆上 //以下字段永远不会同时访问。 //对于channels，waitlink仅由g访问。 //对于信号量，所有字段（包括上面的字段）只有在持有信号根锁时才能访问。 acquiretime int64 releasetime int64 ticket uint32 isSelect bool // g正在参加一个select success bool // 表示通过通道c进行的通信是否成功。如果goroutine因为通过通道c传递了值而被唤醒，则为true；如果goroutine因为通道c关闭而被唤醒，则为false parent *sudog // semaRoot binary tree waitlink *sudog // g.waiting list or semaRoot waittail *sudog // semaRoot c *hchan // channel } 创建方式 使用关键字chan声明一个通道 使用操作符 // 无缓冲channel c := make(chan chantype) // 缓冲channel c := make(chan chantype, buffersize) 看下面这个例子： func main() { c := make(chan int, 2) fmt.Println(c) } c对应的数据结构如下，我们可以看到环形队列的大小为dataqsiz = 2： (gdb) set print pretty on (gdb) p *c $5 = { qcount = 0, dataqsiz = 2, buf = 0xc000074060, elemsize = 8, closed = 0, elemtype = 0x485860, sendx = 0, recvx = 0, recvq = { first = 0x0, last = 0x0 }, sendq = { first = 0x0, last = 0x0 }, lock = { lockRankStruct = {}, key = 0 } } 写入方式 我们开始往channel中写入数据，如下： package main import \"fmt\" func main() { c := make(chan int, 2) // 写入第1个数据 c 现在第8行打下断点，看一下数据结构： (gdb) b 8 Breakpoint 1 at 0x47e30e: file /data/chan2.go, line 8. (gdb) r Starting program: /data/chan2 Breakpoint 1, main.main () at /data/chan2.go:8 8 c }, key = 0}} 现在队列中还没有数据：qcount = 0。继续往下执行： (gdb) p *c $13 = {qcount = 1, dataqsiz = 2, buf = 0xc0000aa060, elemsize = 8, closed = 0, elemtype = 0x485860, sendx = 1, recvx = 0, recvq = {first = 0x0, last = 0x0}, sendq = {first = 0x0, last = 0x0}, lock = {lockRankStruct = {}, key = 0}} 可以看到队列中有1个元素（qcount = 1），写入索引值为1（sendx = 1）,buf的数据如下： (gdb) p *0xc0000aa060 $5 = 1 读取方式 两种读取方式： v := 举个例子如下： func main() { c := make(chan int, 2) go func() { // 打印通道数据 fmt.Println( 结合select使用 package main import ( \"fmt\" \"time\" ) func main() { c1 := make(chan int, 2) c2 := make(chan int, 2) go func() { for { select { case v1 := 结合for-range使用 package main import ( \"fmt\" \"time\" ) func main() { c := make(chan int, 2) go func() { for v := range c { fmt.Println(\"range :\", v) } }() c 参考文章 GO 中 Chan 实现原理 Go channel 实现原理分析 Golang-Channel原理解析 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-02-16 14:57:03 "},"go/gpm/":{"url":"go/gpm/","title":"GPM模型","keywords":"","body":"G(Goroutines) - 协程 携带任务 goroutine时用户态线程，开发者在代码中操作。 G需要绑定到P才能被调度执行 goroutine启动时默认栈大小只有2k，可自动调整容量 数量不限制 可重复使用，在G退出的时候还会把G清理之后放到P本地或者全局的闲置列表gFree中以便复用 P(Processors) - 处理器 分配任务 P在程序启动时创建，并保存在数组中 P为G提供了执行环境，比如内存分配状态 P和M进行绑定，构成一个执行单元 决定同时可以并发任务的数量 数量一般设置为CPU核数/2，可通过配置GOMAXPROCS或者runtime.GOMAXPROCS函数进行指定 M(Machines) - 内核级线程 OS线程的抽象，负责调度任务 当前操作系统分配到go程序的内核线程数 需要和某一个P绑定 GO语言限制M的最大量为10000（一般达不到这个数量），也可通过runtime/debug包中的SetMaxThreads函数指定 M被阻塞的时候会重新创建一个M，如果M空闲的话，会被回收或者睡眠。 GPM模型 线程运行的是goroutine实体，调度器的功能就是把goroutine分配到工作线程上执行。 本地队列 每一个P都有一个本地队列 存放等待运行的G 每个队列的数量不超过256个 新创建的G会优先放入P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列 没有数据竞争，无需加锁处理 全局队列 本地队列满了，会放入全局队列 该队列存储的 G 将被所有的 M 全局共享，为保证数据竞争问题，需加锁处理 M获取G 每个M会从与其绑定的P的本地队列获取G 如果P的本地队列空了，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列偷一半放到自己P的本地队列 Goroutine调度器和OS调度器是通过M结合起来的，每个M都代表了1个内核线程，OS调度器负责把内核线程分配到CPU的核上执行 M与P并不是一一对应的，M阻塞时，P会创建或者切换到一个空闲的M，所以一个P可能创建多个M Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-02-17 08:01:48 "},"go/escape.html":{"url":"go/escape.html","title":"变量逃逸分析","keywords":"","body":" 堆 依赖程序管理内存的分配和释放（各种语言的垃圾回收机制） 读写效率比较低 用来存放全局变量、占用内存大的局部变量、发生逃逸的局部变量 没有固定结构和大小，可以根据需要进行调整 栈 操作系统自动管理内存的分配和释放 一般存放局部变量、函数参数 内存空间比较小（使用ulimit -s查看，一般为8M） 内存结构有特定的结构和寻址方式 逃逸分析 在程序编译阶段根据程序代码中的数据流，对代码中哪些变量需要在栈上分配，哪些变量需要在堆上分配进行静态分析的方法. 我们分析一下这个小程序，看一下结果 package main func sum(a, b int) *int { c := a + b return &c } func main() { s := sum(1, 3) println(s) } 在运行程序时添加-gcflags=\"-m\"参数查看运行过程。 $ go run -gcflags=\"-m\" arr.go # command-line-arguments ./arr.go:3:6: can inline sum ./arr.go:8:6: can inline main ./arr.go:9:10: inlining call to sum ./arr.go:4:2: moved to heap: c 0xc000034768 可以看到变量c被移到堆上，这是因为函数sum返回的是一个指针，变量c在函数外部被引用，所以变量c不能立即销毁，而是逃逸到堆上。 逃逸分析场景 (1)指针逃逸 上面的例子就是指针逃逸的案例，在函数返回指针时，返回的局部变量就会逃逸到堆。 (2)栈空间不足逃逸（空间开辟过大） package main func main() { a := make([]int, 0, 20) // 栈 空间小 b := make([]int, 0, 20000) // 堆 空间过大 逃逸 println(a, b) } 当切片空间足够大时，就会逃逸到堆上，运行结果： $ go run -gcflags=\"-m\" escape.go # command-line-arguments ./escape.go:3:6: can inline main ./escape.go:4:11: make([]int, 0, 20) does not escape ./escape.go:5:11: make([]int, 0, 20000) escapes to heap [0/20]0xc0000346c8 [0/20000]0xc000180000 (3)动态分配不定空间逃逸 package main func main() { c := 20 s := make([]int, 3, c) // 堆 动态分配不定空间 逃逸 println(s) } 由于切片容量是动态分配的，所以变量c发生逃逸，结果如下： $ go run -gcflags=\"-m\" escape2.go # command-line-arguments ./escape2.go:3:6: can inline main ./escape2.go:5:11: make([]int, 3, c) escapes to heap [3/20]0xc000104000 (4)闭包引用对象逃逸 package main import \"fmt\" func Fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } func main() { f := Fibonacci() for i := 0; i Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸，结果如下： $ go run -gcflags=\"-m\" escape3.go # command-line-arguments ./escape3.go:5:6: can inline Fibonacci ./escape3.go:8:9: can inline Fibonacci.func1 ./escape3.go:15:16: inlining call to Fibonacci ./escape3.go:8:9: can inline main.func1 ./escape3.go:18:22: inlining call to main.func1 ./escape3.go:18:13: inlining call to fmt.Printf ./escape3.go:6:2: moved to heap: a ./escape3.go:6:5: moved to heap: b ./escape3.go:8:9: func literal escapes to heap ./escape3.go:8:9: func literal does not escape ./escape3.go:18:22: int(~R0) escapes to heap ./escape3.go:18:13: []interface {}{...} does not escape :1: leaking param content: .this 1 1 2 3 5 8 13 21 34 55 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-02-16 15:05:02 "},"go/uintptr.html":{"url":"go/uintptr.html","title":"uintptr与unsafe.Pointer的关系","keywords":"","body":"golang指针 *T类型：普通指针类型，用于传递对象地址，不能进行指针运算 unsafe.Pointer：通用指针类型，用于转换不同类型的指针，不能进行指针运算，不能读取内存存储的值（必须转换为某一类型的普通指针） uintptr：用于指针运算，GC不把uintptr当指针，uintptr无法持用对象，uintptr类型的目标会被回收 uintptr uintptr是一个整数类型，其大小足以容纳任何指针的位模式。 即使uintptr变量仍然有效，由uintptr变量表示的地址处的数据也可能被GC回收。 // uintptr is an integer type that is large enough to hold the bit pattern of any pointer. type uintptr uintptr 指针运算 package main import ( \"fmt\" \"unsafe\" ) func main() { a := [6]int{1, 2, 3, 4, 5, 6} for index, value := range a { fmt.Printf(\"%d的地址是:%p\\n\", value, &a[index]) } //1的地址是:0xc0000aa060 //2的地址是:0xc0000aa068 //3的地址是:0xc0000aa070 //4的地址是:0xc0000aa078 //5的地址是:0xc0000aa080 //6的地址是:0xc0000aa088 fmt.Printf(\"值：%d，地址：%p \\n\", *(*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&a)) + 5*unsafe.Sizeof(a[5]))), unsafe.Pointer(uintptr(unsafe.Pointer(&a))+5*unsafe.Sizeof(a[5]))) //值：6，地址：0xc0000aa088 } unsafe.Pointer 3.1、什么是unsafe.Pointer Pointer表示指向任意类型的指针。有四种特殊操作可用于类型指针，而其他类型则不可用： 任何类型的指针值都可以转换为Pointer。 Pointer可以转换为任何类型的指针值。 uintptr可以转换为Pointer。 Pointer可以转换为uintptr。 因此，Pointer允许程序破坏类型系统并读取和写入任意内存。使用时应格外小心。 3.2、为什么要有unsafe.Pointer Golang是为了安全和效率设计的，指针类型就是安全的，但是安全会导致逻辑复杂、效率降低，所以就有了unsafe.Pointer，它允许程序员直接读取和写入任意内存，这样就可以提高效率，但是这样操作是很危险的，所以官方不建议我们使用。 3.3、unsafe包的类型和方法 // 任意类型 type ArbitraryType int // 任意整数类型 type IntegerType int // 任意类型的指针 type Pointer *ArbitraryType // 返回类型 x 所占据的字节数，例如，如果x是一个片，Sizeof返回片描述符的大小，而不是片引用的内存的大小。 func Sizeof(x ArbitraryType) uintptr // 返回由x表示的字段的结构内的偏移量，其形式必须为structValue。领域换句话说,它返回结构开头和字段开头之间的字节数。 func Offsetof(x ArbitraryType) uintptr // 返回相应类型的内存对齐系数 func Alignof(x ArbitraryType) uintptr // 将len添加到ptr并返回更新后的指针 func Add(ptr Pointer, len IntegerType) Pointer // 返回一个切片，其底层数组从ptr开始，长度和容量为len func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType a) Sizeof - 返回类型所占据的字节数 fmt.Printf(\"bool size: %d\\n\", unsafe.Sizeof(bool(true))) // bool size: 1 fmt.Printf(\"int8 size: %d\\n\", unsafe.Sizeof(int8(0))) // int8 size: 4 fmt.Printf(\"int32 size: %d\\n\", unsafe.Sizeof(int32(0))) // int32 size: 1 fmt.Printf(\"int64 size: %d\\n\", unsafe.Sizeof(int64(0))) // int64 size: 8 fmt.Printf(\"byte size: %d\\n\", unsafe.Sizeof(byte(0))) // byte size: 1 fmt.Printf(\"string size: %d\\n\", unsafe.Sizeof(\"\")) // string size: 16 b) Offsetof - 返回字段在结构内的偏移量 package main import ( \"fmt\" \"unsafe\" ) type Person struct { name string age int gender bool } func main() { me := Person{\"LSC\", 18, true} myName := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&me)) + unsafe.Offsetof(me.name))) myAge := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&me)) + unsafe.Offsetof(me.age))) myGender := (*bool)(unsafe.Pointer(uintptr(unsafe.Pointer(&me)) + unsafe.Offsetof(me.gender))) *myName = \"KTT\" *myAge = 16 *myGender = false fmt.Println(me) // {KTT 16 false} } c) Alignof - 返回相应类型的内存对齐系数 对齐规则: 结构体字段的偏移量必须为对齐值的整数倍 变量的大小是对齐保证的整数倍 参照具体的例子，查看各种类型的对齐系数 package main import ( \"fmt\" \"unsafe\" ) type Person struct { gender bool // 1 age int32 // 4 address int8 // 1 name string // 16 height int64 // 8 marry byte // 1 } func main() { per := Person{ gender: false, age: 18, address: 88, name: \"lsc\", height: 175, marry: 1, } fmt.Printf(\"p size: %d, align: %d\\n\", unsafe.Sizeof(per), unsafe.Alignof(per)) fmt.Printf(\"gender:%d字节, 字段对齐保证:%d, 偏移地址:%d \\n\", unsafe.Sizeof(per.gender), unsafe.Alignof(per.gender), unsafe.Offsetof(per.gender)) fmt.Printf(\"age:%d字节, 字段对齐保证:%d, 偏移地址:%d \\n\", unsafe.Sizeof(per.age), unsafe.Alignof(per.age), unsafe.Offsetof(per.age)) fmt.Printf(\"address:%d字节, 字段对齐保证:%d, 偏移地址:%d \\n\", unsafe.Sizeof(per.address), unsafe.Alignof(per.address), unsafe.Offsetof(per.address)) fmt.Printf(\"name:%d字节, 字段对齐保证:%d, 偏移地址:%d \\n\", unsafe.Sizeof(per.name), unsafe.Alignof(per.name), unsafe.Offsetof(per.name)) fmt.Printf(\"height:%d字节, 字段对齐保证:%d, 偏移地址:%d \\n\", unsafe.Sizeof(per.height), unsafe.Alignof(per.height), unsafe.Offsetof(per.height)) fmt.Printf(\"marry:%d字节, 字段对齐保证:%d, 偏移地址:%d \\n\", unsafe.Sizeof(per.marry), unsafe.Alignof(per.marry), unsafe.Offsetof(per.marry)) } // p size: 48, align: 8 // gender:1字节, 字段对齐保证:1, 偏移地址:0 // age:4字节, 字段对齐保证:4, 偏移地址:4 // address:1字节, 字段对齐保证:1, 偏移地址:8 // name:16字节, 字段对齐保证:8, 偏移地址:16 // height:8字节, 字段对齐保证:8, 偏移地址:32 // marry:1字节, 字段对齐保证:1, 偏移地址:40 GDB调试结果如下： Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-02-16 15:05:02 "},"go/env.html":{"url":"go/env.html","title":"ENV配置","keywords":"","body":"执行 go env 可以得到所有的环境变量 tal@TALdeMacBook-Pro  ~  go env GO111MODULE=\"on\" GOOS=\"darwin\" GOARCH=\"amd64\" GOBIN=\"\" GOCACHE=\"/Users/tal/Library/Caches/go-build\" GOENV=\"/Users/tal/Library/Application Support/go/env\" GOEXE=\"\" GOFLAGS=\"\" GOHOSTARCH=\"amd64\" GOHOSTOS=\"darwin\" GOINSECURE=\"\" GONOPROXY=\"git.100.com\" GONOSUMDB=\"git.100.com\" GOPATH=\"/Users/tal/go\" GOPRIVATE=\"git.100.com\" GOPROXY=\"https://goproxy.cn,direct\" GOROOT=\"/usr/local/Cellar/go/1.14.5/libexec\" GOSUMDB=\"sum.golang.org\" GOTMPDIR=\"\" GOTOOLDIR=\"/usr/local/Cellar/go/1.14.5/libexec/pkg/tool/darwin_amd64\" GCCGO=\"gccgo\" AR=\"ar\" CC=\"clang\" CXX=\"clang++\" CGO_ENABLED=\"1\" GOMOD=\"/dev/null\" CGO_CFLAGS=\"-g -O2\" CGO_CPPFLAGS=\"\" CGO_CXXFLAGS=\"-g -O2\" CGO_FFLAGS=\"-g -O2\" CGO_LDFLAGS=\"-g -O2\" PKG_CONFIG=\"pkg-config\" GOGCCFLAGS=\"-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/l3/5klj8x_10k3by9d17nr4m3pm0000gn/T/go-build146203019=/tmp/go-build -gno-record-gcc-switches -fno-common\" 修改配置的几种方法 （1）Go.1.13及以上使用 $ go env -w GO111MODULE=on $ go env -w GOPROXY=https://goproxy.cn,direct （2）macOS 或 Linux $ export GO111MODULE=on $ export GOPROXY=https://goproxy.cn 或者 $ echo \"export GO111MODULE=on\" >> ~/.profile $ echo \"export GOPROXY=https://goproxy.cn\" >> ~/.profile $ source ~/.profile GO111MODULE 用环境变量 GO111MODULE 开启或关闭**模块支持**，它有三个可选值：off、on、auto，默认值是 auto。 GO111MODULE=off 无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。 GO111MODULE=on 模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。 GO111MODULE=auto 在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。 在使用模块的时候，GOPATH 是无意义的，不过它还是会把下载的依赖储存在 $GOPATH/src/mod 中，也会把 go install 的结果放在 $GOPATH/bin 中。 GOOS 和 GOARCH GOOS的默认值是我们当前的操作系统， 如果windows，linux,注意mac os操作的上的值是darwin。 GOARCH则表示CPU架构，如386，amd64,arm等。 查看支持的选项： tal@TALdeMacBook-Pro  ~  go tool dist list aix/ppc64 android/386 android/amd64 android/arm android/arm64 darwin/386 darwin/amd64 darwin/arm darwin/arm64 dragonfly/amd64 freebsd/386 freebsd/amd64 freebsd/arm freebsd/arm64 illumos/amd64 js/wasm linux/386 linux/amd64 linux/arm linux/arm64 linux/mips linux/mips64 linux/mips64le linux/mipsle linux/ppc64 linux/ppc64le linux/riscv64 linux/s390x netbsd/386 netbsd/amd64 netbsd/arm netbsd/arm64 openbsd/386 openbsd/amd64 openbsd/arm openbsd/arm64 plan9/386 plan9/amd64 plan9/arm solaris/amd64 windows/386 windows/amd64 windows/arm GOBIN gobin：存放可执行文件的目录的绝对路径 GOCACHE GOCACHE=off表示go build cache被关闭了，建议开启，可以加快构建编译的速度。 开启办法是为GOCACHE设置一个目录即可。 go env -w GOCACHE=path GOPRIVATE 配置私有仓库地址 go env -w GOPRIVATE=\"git.100.com\" GOSUMDB 和 GONOSUMDB 防止从公共模块代理中抓取的模块被篡改：Go 1.13 新推出了一个 GOSUMDB（默认值是 sum.golang.org ，国内无法访问），就是为了实现这个目的，它的值是一个可信任的模块校验和数据库地址，通过指定它，go 将在抓取完模块时（无论是否是经过模块代理抓取的）对所有模块进行哈希校验，只有和校验和数据库中现有的一致时才算抓取成功。同 GONOPROXY 一样，Go 1.13 也为 GOSUMDB 配对发布了一个 GONOSUMDB，用法一致，作用是控制 go 应该忽略校验哪些 module path 下的模块 GOPROXY 和 GONOPROXY GOPROXY：设置代理地址 GONOPROXY：通过设置它我们可以实现控制让哪些 module path 忽略 GOPROXY，无脑回源。比如 GONOPROXY=*.corp.example.com 就意味着 go 在抓取所有 corp.example.com 的三级子域名下的所有模块时都将忽略 GOPROXY 设置直接回源到目标模块的原地址。 Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-02-16 14:58:58 "},"go/pprof.html":{"url":"go/pprof.html","title":"分析工具-pprof","keywords":"","body":"安装graphviz brew install graphviz 安装FlameGraph git clone https://github.com/brendangregg/FlameGraph.git cp flamegraph.pl /usr/local/bin 安装go-torch go get -u github.com/uber/go-torch 🌰测试例子 package main import ( \"net/http\" _ \"net/http/pprof\" ) func main() { http.HandleFunc(\"/hello\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"hello world!\")) }) _ = http.ListenAndServe(\"0.0.0.0:8080\", nil) } 注意： 1、要加入：_ \"net/http/pprof\"​ ​ 运行之后，访问链接：http://127.0.0.1:8080/debug/pprof/ allocs:过去所有内存分配的抽样 block:导致同步原语阻塞的堆栈跟踪 cmdline:当前程序的命令行调用 goroutine:所有当前goroutine的堆栈跟踪 heap:活动对象的内存分配抽样。您可以指定gc GET参数，以便在获取堆样本之前运行gc。 mutex:争用互斥锁持有者的堆栈跟踪 profile:CPU配置文件。可以以秒为单位指定持续时间。获得概要文件后，使用go工具pprof命令来研究概要文件。 threadcreate:导致创建新的操作系统线程的堆栈跟踪 trace:当前程序的执行跟踪。可以以秒为单位指定持续时间。获得跟踪文件后，使用go工具跟踪命令来调查跟踪。 下面的操作都要有请求数据，模仿请求： wrk -c 20 -t 5 -d 3m http://127.0.0.1:8080/hello 生成调用链耗时图 1、采样时间：go tool pprof http://ip:port/debug/pprof/profile?second=60 2、采样状态：看根据历史（-alloc_space）或正在使用（-inuse_space） go tool pprof -alloc_space http://ip:port/debug/pprof/profile?second=60 3、采样筛选： 运行 go tool pprof 命令时加上 –nodefration=0.05 参数，表示如果调用的子函数使用的 CPU、memory 不超过 5%，就忽略它，不要显示在图片中。 方式一：通过URL方式 执行命令：go tool pprof http://localhost:8080/debug/pprof/profile?seconds=20s 通过生成svg文件后，可以直接在浏览器打开如下图： 方式二：通过压测属性的方式 结构体文件： type Info struct { Name string `json:\"name\"` Age int `json:\"age\"` } 使用easyjson和json包对比 ​ 压测文件： package jsons import ( \"encoding/json\" \"testing\" ) var jsonStr = `{ \"name\": \"xiaoming\", \"age\": 18 }` func Benchmark_Json(b *testing.B) { b.ResetTimer() j := new(Info) for i := 1; i 执行以下命令： go test --bench=. -cpuprofile cpu.prof -memprofile mem.prof 生成cpu.prof，mem.prof以及jsons.test(根据包名生成)三个文件 执行命令：go tool pprof cpu.prof，查看具体的信息，以及生成调用链耗时图 或者执行：go tool pprof -http :1234 mem.prof 生成UI页面 执行命令：go-torch -b cpu.prof ​ 🔥火焰图生成方式 要生成火焰图，需要事先安装 FlameGraph工具 每个框代表一个栈里的一个函数 Y轴代表栈深度（栈桢数）。最顶端的框显示正在运行的函数，这之下的框都是调用者。在下面的函数是上面函数的父函数 X轴代表采样总量。从左到右并不代表时间变化，从左到右也不具备顺序性 框的宽度代表占用CPU总时间。宽的框代表的函数可能比窄的运行慢，或者被调用了更多次数。框的颜色深浅也没有任何意义 如果是多线程同时采样，采样总数会超过总时间 go-torch 工具的使用非常简单，没有任何参数的话，它会尝试从 http://localhost:8080/debug/pprof/profile 获取 profiling 数据。它有三个常用的参数可以调整： -u --url：要访问的 URL，这里只是主机和端口部分 -s --suffix：pprof profile 的路径，默认为 /debug/pprof/profile --seconds：要执行 profiling 的时间长度，默认为 30s方式一：通过URL方式 执行命令：go-torch -u http://localhost:8080 -t 20 生成的torch.svg如下： 以UI的方式展示 添加属性：-http=:1234 方式一：通过go tool pprof 执行命令： go tool pprof -http=:1234 http://localhost:8080/debug/pprof/profile 等30s左右，跳转到：http://localhost:1234/ui/ 点击：VIEW -> Flame Graph，可查看火焰图信息 方式二：通过pprof命令 安装：go get -u github.com/google/pprof 然后执行： ~/GolandProjects/bin/pprof -http 127.0.0.1:9090 http://127.0.0.1:8080/debug/pprof/profile Copyright © Lsc 2019 all right reserved，powered by Gitbook修订时间： 2021-02-16 15:05:02 "}}